import { Component, Input, OnInit, Output } from '@angular/core';

 import '../../../../../../node_modules/leaflet-fullscreen/dist/Leaflet.fullscreen.js';
 import '../../../../../../node_modules/leaflet.browser.print/dist/leaflet.browser.print.min.js';
 import '../../../../../../node_modules/leaflet.coordinates/dist/Leaflet.Coordinates-0.1.5.src.js';
 import '../../../../../../node_modules/leaflet.fullscreen/Control.FullScreen.js';




import { ParcelleService } from 'app/_services/parcelle.service';

import { CapteureService } from 'app/_services/capteure.service';
import { AlertesService } from 'app/_services/alertes.service';
import { GeoSearchControl, OpenStreetMapProvider } from 'leaflet-geosearch';
import 'leaflet';
import { DrawEvents, featureGroup, FeatureGroup, icon, latLng, tileLayer } from 'leaflet';
import { ExploitationService } from 'app/_services/exploitation.service.js';

import * as turf from '@turf/turf';





declare let L;


import 'leaflet-measure';

import 'leaflet-search'

import 'leaflet-contextmenu'
import { map, mapTo } from 'rxjs/operators';




import * as LeafletGeotiff from "leaflet-geotiff";
import "leaflet-geotiff/leaflet-geotiff-plotty";
import "leaflet-geotiff/leaflet-geotiff-vector-arrows";
import { getUniqueXDomainValues } from '@swimlane/ngx-charts';
import { ActivatedRoute, Router } from '@angular/router';
import { PopupService } from '../add-modal/popup.service';


import { LangChangeEvent, TranslatePipe,TranslateService } from '@ngx-translate/core';


@Component({
  selector: 'ngx-map-draw',
  templateUrl: './map-draw.component.html',
  styleUrls: ['./map-draw.component.scss'],
  providers: [TranslatePipe]
})
export class MapDrawComponent implements OnInit  {
  map : L.Map
  @Input() id_exp;
  @Input() exp;






  DataCapteurs : any[] = []



  editableLayers = new L.FeatureGroup();
 
  TemperatureIcon: string;
  HumidityIcon: string;
  LightIcon: string;
  SoilTemperatureIcon: string;
  SoilHumidityIcon: string;
  SoilConductivityIcon: string;
  UltrasonicLevelIcon: string;
  new: any[] = []
 
  constructor(
    public translate: TranslateService, private exploitationService: ExploitationService,private parcelleService: ParcelleService ,private route: ActivatedRoute,private router: Router,private modalService: PopupService) {
    this.TemperatureIcon = '../../../../../assets/images/temperature.png'
    this.HumidityIcon = '../../../../../assets/images/humidity.png'
    this.LightIcon = '../../../../../assets/images/light.png'
    this.SoilTemperatureIcon = '../../../../../assets/images/soil_temperature.png'
    this.SoilHumidityIcon = '../../../../../assets/images/soil_humidity.png'
    this.SoilConductivityIcon = '../../../../../assets/images/soil_conductivity.png'
    this.UltrasonicLevelIcon = '../../../../../assets/images/ultrasonic_level.png'
    this.icons  = [this.TemperatureIcon,this.HumidityIcon,this.LightIcon,this.TemperatureIcon,this.TemperatureIcon,this.TemperatureIcon,this.TemperatureIcon]
  }
 
  icons : any[] ;
 
  area;

 
  public dateFin: Date = new Date();
  public dateDebut: Date = new Date();
  feature_ :any;
  capteurs : any
  exploitations : any
  parcelles : any;
  id;
  wSearche;
  wSearcheParcelle = [];
 
  teest : any
  jeojsonExp;
  geojsonExploitatopn = {};
  geojsonPOarcelle;
  messageError;
  
  // polygonDrawer = new L.Draw.Polyline();
  zones = L.featureGroup();
  onDrawEdited(e: any) {
    console.log("Draw Deleted Event!hamza hhh", e);
   
    const { layerType, layer } = e;

    e.layers.eachLayer(function (layer) {
      console.log(layer.toGeoJSON());
  });
  // this.zones.addLayer(e.layer);


  // if (layerType === "polygon") {
  //   var polygonCoordinates = layer._latlngs;
  //   // console.log(polygonCoordinates);
  //   alert(polygonCoordinates)
  // }
if (Object.keys(this.geojsonExploitatopn).length === 0 && !this.id) {
  var seeArea1;
  e.layers.eachLayer( (layer) => {
     seeArea1 = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
});
 
 //this.seeArea = seeArea1/10000;
//  console.log(this.seeArea);
 //alert(seeArea/10000)
 let totalArea = seeArea1/10000;
 
 let testarea = totalArea + parseInt(this.area);
//  layer.addTo(this.map)
 //alert(seeArea1/10000)
 console.log(totalArea)
 console.log(this.area)
 console.log(testarea)
 
// if (testarea < 400000) {
 
  e.layers.eachLayer( (layer) => {
    
 this.jeojsonExp = {}
this.jeojsonExp = layer.toGeoJSON();
});

 this.jeojsonExp.properties.matricule= "";
 this.jeojsonExp.properties.region= "";
 this.jeojsonExp.properties.superficie= seeArea1/10000;
 this.messageError = null;
// } 
// else {
//   this.messageError = (totalArea + this.area)  +" vous depassé 100h";
//   layer.remove();
//   new L.Draw.Polygon(this.map, this.drawOptions.draw.polygon).enable();
// }
 // console.log(JSON.stringify(this.jeojsonExp))
//  alert(JSON.stringify(jeojson))
 


 
 this.modalService.open('add');


}else{
  
  e.layers.eachLayer( (layer) => {
     seeArea1 = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
});
 //this.seeArea = seeArea1/10000;
//  console.log(this.seeArea);
 //alert(seeArea/10000)
 e.layers.eachLayer( (layer) =>{
  this.geojsonPOarcelle = layer.toGeoJSON();
});
 
 this.geojsonPOarcelle.properties.date_debut = this.dateDebut;
    this.dateFin.setDate(this.dateFin.getDate() + 30)
    this.geojsonPOarcelle.properties.date_fin = this.dateFin;
 this.geojsonPOarcelle.properties.matricule= "";
 this.geojsonPOarcelle.properties.variete = "";
 this.geojsonPOarcelle.properties.superficie= seeArea1/10000;
 // console.log(JSON.stringify(this.geojsonPOarcelle))
//  alert(JSON.stringify(jeojson))
//  layer.addTo(this.map)
 //new L.Draw.Polygon(this.map, this.drawOptions.draw = null).disable();
if (this.jeojsonExp) {
 console.log(this.jeojsonExp.geometry.coordinates);
 console.log(this.geojsonPOarcelle.geometry.coordinates);
 var searchWithin = turf.polygon(this.jeojsonExp.geometry.coordinates);
 var points = turf.points(this.geojsonPOarcelle.geometry.coordinates[0]);
 var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);
 console.log(ptsWithin);
}else{
 console.log(this.wSearche);
 console.log(this.wSearcheParcelle);
 var searchWithin = turf.polygon(this.wSearche[0]);
 var points = turf.points(this.geojsonPOarcelle.geometry.coordinates[0]);
 var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);
 for(let i = 0; i < this.wSearcheParcelle.length; i++){
  var p = turf.polygon(this.wSearcheParcelle[i][0]);
  var d = turf.pointsWithinPolygon(points, p);
  if (d.features.length != 0){
   this.messageError = "Veuillez dessiner votre parcelle à l'exterieur de votre parcelle!";
   console.log("madazch")
   layer.remove()
   this.geojsonPOarcelle = null;
   console.log("dkhlti f parcelle")
   break;
  }else{
   this.messageError = null;
    console.log("mzn madkhltich f parcelle")}
 }
 console.log(ptsWithin);
}
 let len = this.geojsonPOarcelle.geometry.coordinates[0];
 if (ptsWithin.features.length == len.length) {
   console.log("daz")
   this.messageError = null;
 }else{
   this.messageError = "Veuillez dessiner votre parcelle à l'intérieur de votre exploitation";
   this.geojsonPOarcelle = null;
   console.log("madazch")
   layer.remove()
 }
 this.modalService.open('add');
}
  }
  getGeojson(event){
    console.log(event);
    
    // console.log(this.geojsonExploitatopn);
    //this.router.navigate(['/pages/Adminstrator/addParcelle'], {queryParams: {...event.geometry,...event.properties},skipLocationChange: true});
    // this.onDrawStart(event);
    // this.polygonDrawer.enable();
 
   if (event == "modifer") {

    
    // new L.edit.Polygon(this.map, this.drawOptions.edit).enable();
   }else{
    this.geojsonExploitatopn = event;
    new L.Draw.Polygon(this.map, this.drawOptions.draw.polygon.shapeOptions.color = '#000');
    new L.Draw.Polygon(this.map, this.drawOptions.draw.polygon).enable();
   }
  
  }
  geoParcelle(event){
    console.log('submitData trtytt');
if (Object.keys(this.geojsonExploitatopn).length !== 0) {
  this.exploitationService.desinerExploitation(this.geojsonExploitatopn).subscribe(res => {
  
    console.log(res.state);
    console.log(res);
    if (res.state == true) {
      let k = event;
      k.properties.id_exploitation = res.id_exploitation
      k.properties.id_contrat = res.id_contrat
     this.submitData(k);
    }
  })
} else {
  console.log('submitData');
  this.submitData(event);
 
}

  }
  ngOnInit(){
    this.changeMapLangeuge();
    
    this.translate.onLangChange.subscribe((event: LangChangeEvent) => { //Live reload
      
      this.changeMapLangeuge();
  });
    this.route.paramMap.subscribe( params => {
     if(params.get('area')){
      this.area = params.get('area');
      console.log(this.area);
     }else{
       this.id = params.get('geo');
      console.log(this.id)
      if (this.id) {
        new L.Draw.Polygon(this.map, this.drawOptions.draw.polygon.shapeOptions.color = '#000');
        new L.Draw.Polygon(this.map, this.drawOptions.draw.polygon).enable();
       }
     }
    })

  }
   redraw() {
    var lat_tmp = this.map.getCenter().lat;
    var lng_tmp = this.map.getCenter().lng;
    this.map.setView([-66.22149259832975, -1.142578125]);
    console.log("Reloading...");
    setTimeout(function () {
       // waitForTilesToLoad()
    }, 50000);
    this.map.setView([lat_tmp, lng_tmp]);
    console.log("Done");
}

  private changeMapLangeuge(): void {
       
    // this.drawLocal.
    
    this.drawLocal.draw.handlers.polygon.tooltip.start = this.translateMenuTitle("draw.handlers.polygon.tooltip.start");

this.redraw();
  // L.update()
  // this.drawLocal.invalidateSize(); 
}
 /**
   * @param menuItem
   * @param prefix
   */
  private translateMenuTitle(menuItem, prefix: string = '') {
    
    var key = '';
    // try {
    //   debugger
    //     key = (prefix !== '')
    //         ? PagesComponent.getMenuItemKey(menuItem, prefix)
    //         : PagesComponent.getMenuItemKey(menuItem);
    // }
    // catch (e) {
    //     return;
    // }

    this.translate.get(menuItem).subscribe((translation: string) => {
      
        key = translation;
    });
return key;
}
  onDrawDeleted(e: any) {
    e.layers.eachLayer((layer) => {
      this.zones.removeLayer(layer);
    });
    console.log("Draw Deleted Event!", e);
    console.log(this.zones.getLayers());
  }
  submitData(k){
  //  debugger
    this.parcelleService.dessinerParcelle(k).subscribe(response => {
      console.log(response);
      debugger
      this.cancel();
    })
   
  }
 
  cancel(){
    this.router.navigate([`/pages/iot-dashboard/`]);
  }
 
  
 
  json;
 
 
  drawnItems: FeatureGroup = featureGroup();
 
 
 
 
 
  options = {
    layers: [
     L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}&hl=ar-MA&gl=MA',{
       subdomains:['mt0','mt1','mt2','mt3']
     })
    ],
   zoom: 18,
    center: [ 31.791702,  -7.09262 ],
   contextmenu: true,
   contextmenuWidth: 140,
     // contextmenuItems: [{
     //     text: 'Show coordinates',
     //     callback: this.showCoordinates
     // }, {
     //     text: 'Center map here',
     //     callback: this.centerMap
     // }, '-', {
     //     text: 'Zoom in',
     //     callback: this.zoomIn
     // }, {
     //     text: 'Zoom out',
     //     // icon: 'images/zoom-out.png',
     //     callback: this.zoomOut
     // }]
  };
 
 
 
 
 public showCoordinates(e: any) {
   alert(e.latlng);
 }
 
 
 public centerMap(e: any) {
   alert("centerMap")
   this.map.panTo(e.latlng);
 }
 
 public zoomIn(e: any) {
   alert("zoomIn")
 
   this.map.zoomIn();
 }
 
 
 public zoomOut(e: any) {
   alert("zoomOut")
 
   this.map.zoomOut();
 }
 
 public inExploitation(e: any) {
   alert("inExploitation");
 }
 
 public inParcelle(e: any) {
   alert("inParcelle");
 }
 
 public inCapteur(e: any) {
   alert("inCapteur");
 }
 
 

 drawOptions = {
   position: 'topleft',

   draw: {
     polygon: {
      shapeOptions: {
        color: '#FF0000'
    },
     },
     
     marker: false,
     
     polyline: false,
     rectangle: false,
     circle: false,
     circlemarker: false,
   },
   edit: {
    featureGroup: this.drawnItems,
    // remove: this.drawnItems
  }
   // draw: false,
   // edit: {featureGroup: this.editableLayers, remove: false}
 };
 
 
 drawLocal: any = {
  draw: {
    toolbar: {
      actions: {
        title: 'Cancel - your text-',
        text: '- your text-'
      },
      finish: {
        title: '- your text-',
        text: '- your text-'
      },
      undo: {
        title: '- your text-',
        text: '- your text-'
      },
      buttons: {
        polyline: '- your text-',
        polygon: '- your text-',
        rectangle: '- your text-',
        circle: '- your text-',
        marker: '- your text-',
        circlemarker: '- your text-'
      }
    },
    handlers: {
      circle: {
        tooltip: {
          start: '- your text-'
        },
        radius: '- your text-'
      },
      circlemarker: {
        tooltip: {
          start: '- your text-.'
        }
      },
      marker: {
        tooltip: {
          start: '- your text-.'
        }
      },
      polygon: {
        tooltip: {
          start: 'polygonh',
          cont: '- your text-.',
          end: '- your text-.'
        }
      },
      polyline: {
        error: '<strong>Error:</strong> shape edges cannot cross!',
        tooltip: {
          start: 'Click to start drawing line.',
          cont: 'Click to continue drawing line.',
          end: 'Click last point to finish line.'
        }
      },
      rectangle: {
        tooltip: {
          start: '- your text-.'
        }
      },
      simpleshape: {
        tooltip: {
          end: 'Release mouse to finish drawing.'
        }
      }
    }
  },
  edit: {
    toolbar: {
      actions: {
        save: {
          title: 'Save changes',
          text: 'Save'
        },
        cancel: {
          title: 'Cancel editing, discards all changes',
          text: 'Cancel'
        },
        clearAll: {
          title: 'Clear all layers',
          text: 'Clear All'
        }
      },
      buttons: {
        edit: 'Edit layers',
        editDisabled: 'No layers to edit',
        remove: 'Delete layers',
        removeDisabled: 'No layers to delete'
      }
    },
    handlers: {
      edit: {
        tooltip: {
          text: 'Drag handles or markers to edit features.',
          subtext: 'Click cancel to undo changes.'
        }
      },
      remove: {
        tooltip: {
          text: 'Click on a feature to remove.'
        }
      }
    }
  }
 };
 closeModal(id: string) {
  this.modalService.close(id);
}

openModal(id: string) {
  this.modalService.open(id);
}

 public onDrawCreated(e: any) {
  console.log("Draw Deleted Event!hamza hhh", e);
  const { layerType, layer } = e;
  console.log(layer.toGeoJSON());
    
  
   this.zones.addLayer(e.layer);

   this.drawnItems.addLayer((e as DrawEvents.Created).layer);
   // if (layerType === "polygon") {
   //   var polygonCoordinates = layer._latlngs;
   //   // console.log(polygonCoordinates);
   //   alert(polygonCoordinates)
   // }
if (Object.keys(this.geojsonExploitatopn).length === 0 && !this.id) {
  
  let seeArea1 = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
  //this.seeArea = seeArea1/10000;
 //  console.log(this.seeArea);
  //alert(seeArea/10000)
  let totalArea = seeArea1/10000;
  
  let testarea = totalArea + parseInt(this.area);
  layer.addTo(this.map)
  //alert(seeArea1/10000)
  console.log(totalArea)
  console.log(this.area)
  console.log(testarea)
  
// if (testarea < 400000) {
  this.jeojsonExp = layer.toGeoJSON();
 
  this.jeojsonExp.properties.matricule= "";
  this.jeojsonExp.properties.region= "";
  this.jeojsonExp.properties.superficie= seeArea1/10000;
  this.messageError = null;
// } 
// else {
//   this.messageError = (totalArea + this.area)  +" vous depassé 100h";
//   layer.remove();
//   new L.Draw.Polygon(this.map, this.drawOptions.draw.polygon).enable();
// }
  // console.log(JSON.stringify(this.jeojsonExp))
 //  alert(JSON.stringify(jeojson))
  
 

  
  this.modalService.open('add');


}else{
  let seeArea1 = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
  //this.seeArea = seeArea1/10000;
 //  console.log(this.seeArea);
  //alert(seeArea/10000)
   this.geojsonPOarcelle = layer.toGeoJSON();
  this.geojsonPOarcelle.properties.date_debut = this.dateDebut;
     this.dateFin.setDate(this.dateFin.getDate() + 30)
     this.geojsonPOarcelle.properties.date_fin = this.dateFin;
  this.geojsonPOarcelle.properties.matricule= "";
  this.geojsonPOarcelle.properties.variete = ""
  this.geojsonPOarcelle.properties.superficie= seeArea1/10000;
  // console.log(JSON.stringify(this.geojsonPOarcelle))
 //  alert(JSON.stringify(jeojson))
  layer.addTo(this.map)
  //new L.Draw.Polygon(this.map, this.drawOptions.draw = null).disable();
if (this.jeojsonExp) {
  console.log(this.jeojsonExp.geometry.coordinates);
  console.log(this.geojsonPOarcelle.geometry.coordinates);
  var searchWithin = turf.polygon(this.jeojsonExp.geometry.coordinates);
  var points = turf.points(this.geojsonPOarcelle.geometry.coordinates[0]);
  var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);
  console.log(ptsWithin);
}else{
  console.log(this.wSearche);
  console.log(this.wSearcheParcelle);
  var searchWithin = turf.polygon(this.wSearche[0]);
  var points = turf.points(this.geojsonPOarcelle.geometry.coordinates[0]);
  var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);
  for(let i = 0; i < this.wSearcheParcelle.length; i++){
   var p = turf.polygon(this.wSearcheParcelle[i][0]);
   var d = turf.pointsWithinPolygon(points, p);
   if (d.features.length != 0){
    this.messageError = "Veuillez dessiner votre parcelle à l'exterieur de votre parcelle!";
    console.log("madazch")
    layer.remove()
    this.geojsonPOarcelle = null;
    console.log("dkhlti f parcelle")
    break;
   }else{
    this.messageError = null;
     console.log("mzn madkhltich f parcelle")}
  }
  console.log(ptsWithin);
}
  let len = this.geojsonPOarcelle.geometry.coordinates[0];
  if (ptsWithin.features.length == len.length) {
    console.log("daz")
    this.messageError = null;
  }else{
    this.messageError = "Veuillez dessiner votre parcelle à l'intérieur de votre exploitation";
    this.geojsonPOarcelle = null;
    console.log("madazch")
    layer.remove()
  }
  this.modalService.open('add');
}
 }
 public onDrawStart(e: any) {
    //alert('Draw Started Event!')
 }
 
 
 
  onMapReady(map: L.Map) {
   this.map = map
 
 
  //  L.Edit.Poly = L.Edit.Poly.extend({
  //   options: {
  //     icon: new L.DivIcon({
  //       iconSize: new L.Point(10, 10),
  //       className: 'leaflet-div-icon leaflet-editing-icon my-own-icon',
  //     }),
  //   },
  // }).addTo(map);
 
 
   L.control.fullscreen({
        position: 'topleft', // change the position of the button can be topleft, topright, bottomright or bottomleft, defaut topleft
        title: 'Show me the fullscreen !', // change the title of the button, default Full Screen
        titleCancel: 'Exit fullscreen mode', // change the title of the button when fullscreen is on, default Exit Full Screen
        content: null, // change the content of the button, can be HTML, default null
        forceSeparateButton: true, // force seperate button to detach from zoom buttons, default false
        forcePseudoFullscreen: true, // force use of pseudo full screen even if full screen API is available, default false
        fullscreenElement: false // Dom element to render in full screen, false by default, fallback to map._container
      }).addTo(map);
 
 
 
  map.on('enterFullscreen', () => map.invalidateSize());
  map.on('exitFullscreen', () => map.invalidateSize());
 
 L.control.browserPrint({
   title: 'Imprimer la carte',
   printModesNames: {
     Portrait: 'Portrait',
     Landscape: 'Paysage',
     Auto: 'Auto',
     Custom: 'Séléctionnez la zone'
   }
 }).addTo(map);
 L.control.coordinates().addTo(map);
 
 
 
 var measureControl = L.control.measure(
   {
       measureControl: true,
       position: 'topleft',
       primaryAreaUnit: 'hectares',
       activeColor: '#ABE67E',
       completedColor: '#C8F2BE',
       popupOptions: { className: 'leaflet-measure-resultpopup', autoPanPadding: [10, 10] },
       captureZIndex: 10000,
       labels: { "label": "Label translation" }
     }
 
 );
 measureControl.addTo(map);
 
 
 const provider = new OpenStreetMapProvider();
 const searchControl = new GeoSearchControl({
   provider: provider,
   autoClose: true
 });
 map.addControl(searchControl)
 
 // L.Control.measureControl().addTo(map);
 
 // var drawControl = new L.Control.Draw({
 //   draw: {
 //       polygon: true,
 //       marker: true,
 //       polyline: false,
 //       rectangle: false,
 //       circle: false,
 //       circlemarker: false,
 
 //   },
 //   edit: {

 //       edit: true
 //   }
 // });
 
 // drawControl.addTo(map)
 
 
 
 // var popup = L.popup().setContent(`<p>Hello world!<br />This is a nice popup.</p>`); 
 
 // map.on('contextmenu',function(){
 //    alert("contextmenuuuu")
 //    map.openPopup(popup);
 // });
 
 
 
 // map.on('contextmenu',function(e){
 //    alert("contextmenuuuu")
 
 
 //    L.popup()
 //    .setContent('<p>Hello</pre>')
 //    .addTo(map)
 //    .openOn(map)
 // });
 
 
 
 
 var exploitation
 var exploitationsList = []
 var exploitationsGroupe
 var exploitationsListgroupe=[]
if(this.id){
  this.exploitationService.getExploitations().subscribe((json: any) => {
    // this.teest = json.features
  
    exploitation = L.geoJSON(json, {
      onEachFeature: (feature, layer) => {
 if(feature.properties.id_exploitation == this.id){
   this.wSearche = feature.geometry.coordinates;
        // if(feature.properties.id_exploitation == '99'){
        //   var imageBounds = layer.getBounds();
        //   var imageUrl = '../../../../../assets/images/Albedo_parcelle.png';
        //   var imageLayer = L.imageOverlay(imageUrl,imageBounds).addTo(map);
        // }
  
  
        let popupContent = `<p> id_exploitation: ${feature.properties.id_exploitation}</p>
        <p> region: ${feature.properties.region}</p>`;
        layer.bindPopup(popupContent);
        var element = L.geoJSON(feature,{
          contextmenu: true,
          contextmenuItems: [{
                text: 'In exploitation',
                callback: this.inExploitation
            }, '-'],
          onEachFeature: (feature, layer) => {
            let popupContent = `<p> id_exploitation: ${feature.properties.id_exploitation}</p>
            <p> region: ${feature.properties.region}</p>`;
            layer.bindPopup(popupContent);
          },
          style: function (feature) {
            return {
              color: '#fff'
            };
          },
  
  
              // contextmenuItems: [{
          //     text: 'Show coordinates',
          //     callback: this.showCoordinates
          // }, {
          //     text: 'Center map here',
          //     callback: this.centerMap
          // }, '-', {
          //     text: 'Zoom in',
          //     callback: this.zoomIn
          // }, {
          //     text: 'Zoom out',
          //     // icon: 'images/zoom-out.png',
          //     callback: this.zoomOut
          // }]
  
        }).addTo(map);
        exploitationsList.push({'id_exploitation': feature.properties.id_exploitation,'feature':element})
        exploitationsListgroupe.push(element)
        map.fitBounds(layer.getBounds()); 
       
 }
  
      },
      style: function (feature) {
        return {
          color: '#fff',
          fillOpacity : 0
        };
      }
    })
  
    map.fitBounds(exploitation.getBounds()); // l3iba dyal fit polygon
    // this.exploitations = exploitation
    // this.exploitations = L.layerGroup(exploitationsList)
    this.exploitations = exploitationsList
  
  
    exploitationsGroupe = L.layerGroup(exploitationsListgroupe);
  
  
  })
}
 
 // L.marker([ 31.791702,  -7.09262 ]).addTo(map);
 var parcelles;
 if(this.id){
  this.parcelleService.getParcelles().subscribe((json: any) => {
    // this.teest = json.features
  
    parcelles = L.geoJSON(json, {
      onEachFeature: (feature, layer) => {
 if(feature.properties.id_exploitation == this.id){
  this.wSearcheParcelle.push(feature.geometry.coordinates);
        // if(feature.properties.id_exploitation == '99'){
        //   var imageBounds = layer.getBounds();
        //   var imageUrl = '../../../../../assets/images/Albedo_parcelle.png';
        //   var imageLayer = L.imageOverlay(imageUrl,imageBounds).addTo(map);
        // }
  
  
        let popupContent = `<p> id_exploitation: ${feature.properties.id_exploitation}</p>
        <p> region: ${feature.properties.region}</p>`;
        layer.bindPopup(popupContent);
        var element = L.geoJSON(feature,{
          contextmenu: true,
          contextmenuItems: [{
                text: 'In exploitation',
                callback: this.inExploitation
            }, '-'],
          onEachFeature: (feature, layer) => {
            let popupContent = `<p> id_exploitation: ${feature.properties.id_exploitation}</p>
            <p> region: ${feature.properties.region}</p>`;
            layer.bindPopup(popupContent);
          },
          style: function (feature) {
            return {
              color: '#000'
            };
          },
  
  
              // contextmenuItems: [{
          //     text: 'Show coordinates',
          //     callback: this.showCoordinates
          // }, {
          //     text: 'Center map here',
          //     callback: this.centerMap
          // }, '-', {
          //     text: 'Zoom in',
          //     callback: this.zoomIn
          // }, {
          //     text: 'Zoom out',
          //     // icon: 'images/zoom-out.png',
          //     callback: this.zoomOut
          // }]
  
        }).addTo(map);
        exploitationsList.push({'id_exploitation': feature.properties.id_exploitation,'feature':element})
        exploitationsListgroupe.push(element)
        map.fitBounds(layer.getBounds()); 
       
 }
  
      },
    })
  
    map.fitBounds(parcelles.getBounds()); // l3iba dyal fit polygon
    // this.exploitations = exploitation
    // this.exploitations = L.layerGroup(exploitationsList)
    this.exploitations = exploitationsList
  
  
    exploitationsGroupe = L.layerGroup(exploitationsListgroupe);
  
  
  })
}
 

 
 var Temperature = L.icon({
   iconUrl: this.TemperatureIcon,
 });
 
 var Humidity = L.icon({
   iconUrl: this.HumidityIcon,
 });
 
 var Light = L.icon({
   iconUrl: this.LightIcon,
 });
 var SoilTemperature = L.icon({
   iconUrl: this.SoilTemperatureIcon,
 });
 var SoilHumidity = L.icon({
   iconUrl: this.SoilHumidityIcon,
 });
 var SoilConductivity = L.icon({
   iconUrl: this.SoilConductivityIcon,
 });
 
 var UltrasonicLevel = L.icon({
   iconUrl: this.UltrasonicLevelIcon,
 });
 
   var capteur
   var capteursList = []
   var capteursGroupe
   var capteursListgroupe=[]
   var temperatureList = []
   var humidityList = []
   var lightList = []
   var soil_temperatureList = []
   var soil_humidityList = []
   var soil_conductivityList = []
   var ultrasonic_levelList = []
   var temperatureListgroupe = []
   var humidityListgroupe = []
   var lightListgroupe = []
   var soil_temperatureListgroupe = []
   var soil_humidityListgroupe = []
   var soil_conductivityListgroupe = []
   var ultrasonic_levelListgroupe = []
   var temperatureGroupe
   var humidityGroupe
   var lightGroupe
   var soil_temperatureGroupe
   var soil_humidityGroupe
   var soil_conductivityGroupe
   var ultrasonic_levelGroupe
 

 
 
 
 //   var searchLayer = L.geoJson({"type":"Feature","properties":{"id_polygon":"polygon_1"},"geometry":{"type":"Polygon","coordinates":[[[-9.514031,30.165017],[-9.519439,30.167762],[-9.520683,30.163087],[-9.517164,30.15934],[-9.512143,30.162828],[-9.514031,30.165017]]]}}).addTo(map);
 // //... adding data in searchLayer ...
 //   L.map('map', { searchControl: {layer: searchLayer} });
 
 
 // var searchLayer = L.layerGroup().addTo(map);
 // //... adding data in searchLayer ...
 // map.addControl( new L.Control.Search({layer: searchLayer}) );
 // //searchLayer is a L.LayerGroup contains searched markers
 
 
 
 
 
 
 // var featuresLayer = new L.GeoJSON({"type":"Feature","properties":{"id_polygon":"polygon"},"geometry":{"type":"Polygon","coordinates":[[[-9.514031,30.165017],[-9.519439,30.167762],[-9.520683,30.163087],[-9.517164,30.15934],[-9.512143,30.162828],[-9.514031,30.165017]]]}});
 
 // var featuresLayer = new L.GeoJSON([{"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[-9.514031,30.165017],[-9.519439,30.167762],[-9.520683,30.163087],[-9.517164,30.15934],[-9.512143,30.162828],[-9.514031,30.165017]]]} ,"properties":{"id_polygon":"polygon1", "tty":"gkll"}}, {"type":"Feature","properties":{"id_polygon":"polygon2"},"geometry":{"type":"Polygon","coordinates":[[[-9.516907,30.157596],[-9.524717,30.156445],[-9.52004,30.15344],[-9.518709,30.154776],[-9.516864,30.156112],[-9.527636,30.160008],[-9.516907,30.157596]]]}}]);
 
 // var featuresLayer = new L.GeoJSON(this.teest);
 
 // this.teest
 // map.addLayer(featuresLayer);
 // var featuresLayer = new L.GeoJSON([ { "type": "Feature", "geometry": { "type": "MultiPolygon", "coordinates": [ [ [ [ -9.50193149, 30.16774386 ], [ -9.50090553, 30.157270524 ], [ -9.498511625, 30.157441517 ], [ -9.498041394, 30.163469029 ], [ -9.491158916, 30.163811015 ], [ -9.49205663, 30.166846145 ], [ -9.499537584, 30.167615615 ], [ -9.50193149, 30.16774386 ] ] ] ] }, "properties": { "id_exploitation": "1", "region": "Souss-Massa", "id_client": null, "x": 30.163888049725585, "y": -9.497859134901429, "matricule": "Exp1", "superficie": 595348.8, "parcelles_nbr": 4 } }, { "type": "Feature", "geometry": { "type": "MultiPolygon", "coordinates": [ [ [ [ -9.50218798, 30.16393926 ], [ -9.509882675, 30.164238498 ], [ -9.510310158, 30.152140726 ], [ -9.502700959, 30.152097978 ], [ -9.50218798, 30.16393926 ] ] ] ] }, "properties": { "id_exploitation": "2", "region": "Souss-Massa", "id_client": null, "x": 30.158116865824038, "y": -9.50628350471131, "matricule": "Exp2", "superficie": 978950.25, "parcelles_nbr": 4 } }, { "type": "Feature", "geometry": { "type": "MultiPolygon", "coordinates": [ [ [ [ -9.490603188, 30.163725518 ], [ -9.491201664, 30.153850659 ], [ -9.481284056, 30.152867448 ], [ -9.481497798, 30.163725518 ], [ -9.490603188, 30.163725518 ] ] ] ] }, "properties": { "id_exploitation": "3", "region": "Souss-Massa", "id_client": null, "x": 30.15846321605999, "y": -9.48607617660439, "matricule": "Exp3", "superficie": 1053962.4, "parcelles_nbr": 3 } } ]);
 // setTimeout(function ggg() {
 
 // // var featuresLayer = L.geoJSON([ { "type": "Feature", "geometry": { "type": "MultiPolygon", "coordinates": [ [ [ [ -9.50193149, 30.16774386 ], [ -9.50090553, 30.157270524 ], [ -9.498511625, 30.157441517 ], [ -9.498041394, 30.163469029 ], [ -9.491158916, 30.163811015 ], [ -9.49205663, 30.166846145 ], [ -9.499537584, 30.167615615 ], [ -9.50193149, 30.16774386 ] ] ] ] }, "properties": { "id_exploitation": "1", "region": "Souss-Massa", "id_client": null, "x": 30.163888049725585, "y": -9.497859134901429, "matricule": "Exp1", "superficie": 595348.8, "parcelles_nbr": 4 } }, { "type": "Feature", "geometry": { "type": "MultiPolygon", "coordinates": [ [ [ [ -9.50218798, 30.16393926 ], [ -9.509882675, 30.164238498 ], [ -9.510310158, 30.152140726 ], [ -9.502700959, 30.152097978 ], [ -9.50218798, 30.16393926 ] ] ] ] }, "properties": { "id_exploitation": "2", "region": "Souss-Massa", "id_client": null, "x": 30.158116865824038, "y": -9.50628350471131, "matricule": "Exp2", "superficie": 978950.25, "parcelles_nbr": 4 } }, { "type": "Feature", "geometry": { "type": "MultiPolygon", "coordinates": [ [ [ [ -9.490603188, 30.163725518 ], [ -9.491201664, 30.153850659 ], [ -9.481284056, 30.152867448 ], [ -9.481497798, 30.163725518 ], [ -9.490603188, 30.163725518 ] ] ] ] }, "properties": { "id_exploitation": "3", "region": "Souss-Massa", "id_client": null, "x": 30.15846321605999, "y": -9.48607617660439, "matricule": "Exp3", "superficie": 1053962.4, "parcelles_nbr": 3 } } ]);
 
 // var searchControl = new L.Control.Search({layer: capteur, propertyName: 'id_capteur', circleLocation:true});
 
 // searchControl.on('search_locationfound', function(e) {
 
 //   map.fitBounds(e.layer.getBounds());
 //   e.layer.setStyle({fillColor: '#3f0', color: '#0f0'});
 
 
 // }).on('search_collapsed', function(e) {
 
 //   exploitation.eachLayer(function(layer) {   //restore feature color
 //     exploitation.resetStyle(layer);
 // });
 // });
 
 // map.addControl( searchControl );  //inizialize search control
 
 // }, 7000)
 
 
 
 
 
 
 
 
 
 
 
 
 

 
  
 // var searchControl = new L.Control.Search({layer: this.teest , propertyName: 'id_capteur', circleLocation:true});
 // searchControl.on('search_locationfound', function(e) {
 //   alert("1")
 //     e.layer.setStyle({fillColor: 'white', color: 'white', fillOpacity: 0.5});
 //     map.fitBounds(e.layer.getBounds());
 //     if(e.layer._popup)
 //         e.layer.openPopup();
 // }).on('search_collapsed', function(e) {
 //   alert("2")
 //   this.teest.eachLayer(function(layer) {
 //     this.teest.resetStyle(layer);
 //     });
 // });
 // map.addControl( searchControl );  //inizialize search control
 
 
 
 
 
 // L.tileLayer('file:////home/fadwa/Desktop/testqgis/testtiff/outputtiles//{z}/{x}/{y}.png', {
 //   minZoom: 12,
 //   maxZoom: 12,
 //   tms: false,
 //   attribution: 'Generated by TilesXYZ'
 // }).addTo(map);
 
 
 
 
 
 // var parse_georaster = require("georaster");
 
 // var GeoRasterLayer = require("georaster-layer-for-leaflet");
 
 
 
 // var url_to_geotiff_file = "../../../../../assets/images/ETc_16_5003.tif";
 
 // fetch(url_to_geotiff_file)
 //   .then(response => response.arrayBuffer())
 //   .then(arrayBuffer => {
 //     parse_georaster(arrayBuffer).then(georaster => {
 //       console.log("georaster:", georaster);
 
 //       /*
 //           GeoRasterLayer is an extension of GridLayer,
 //           which means can use GridLayer options like opacity.
 
 //           Just make sure to include the georaster option!
 
 //           Optionally set the pixelValuesToColorFn function option to customize
 //           how values for a pixel are translated to a color.
 
 //           http://leafletjs.com/reference-1.2.0.html#gridlayer
 //       */
 //       var layer = new GeoRasterLayer({
 //           georaster: georaster,
 //           opacity: 1,
 //           pixelValuesToColorFn: values => values[0] === 42 ? '#ffffff' : '#000000',
 //           resolution: 64 // optional parameter for adjusting display resolution
 //       });
 //       layer.addTo(map);
 
 
 //   });
 // });
 
 
 
 
 
 
 // var url_to_geotiff_file = "../../../../../assets/images/ETc_16_5003.tif";
 // url_to_geotiff_file.addTo(map);
 
 
 // var imageUrl = '../../../../../assets/images/ETc_16_5003.tif',
 //   imageBounds = [center, [-35.8650, 154.2094]];
 
 // L.imageOverlay(imageUrl, imageBounds).addTo(map);
 // L.imageOverlay(imageUrl, imageBounds).bringToFront();
 
 // const option = {
 //   band: 0,
 //   name: 'Custom Mask',
 //   opacity: 1,
 //   renderer: new plotty.Plotty({
 //       colorScale: 'greys'
 //   })
 // };
 
 
 // new geotiff.LeafletGeotiff('../../../../../assets/images/ETc_16_5003.tif', option).addTo(this.map)
 
 
 // plotty.addColorScale("mycolorscale", ["#00ff00", "#0000ff", "#ff0000"], [0, 0.5, 1]);
 
 // let windDirection = new L.LeafletGeotiff('../../../../../assets/images/ETc_16_5003.tif',
 // {
 //     band: 0,
 //     name: 'Wind speed',  		
 //     renderer: new L.LeafletGeotiff.VectorArrows()
 // }).addTo(this.map);
 
 
 
 // ETc_5001.png
 
 
 // xmin
 // -8.580040
 
 
 // ymin
 // 30.570543
 
 
 // xmax
 // -8.564707
 
 
 // ymax
 // 30.596915
 
 
 
 // SELECT ST_YMax(geom) as Xmin FROM (select geom from parcelles where id_parcelle='5001') As f(geom);
 
 
 // var test = L.imageOverlay('../../../../../assets/images/ETc_5001.png', [[-8.564707,30.596915],[-8.580040,30.570543]]).addTo(map)
 
 
 // const test = LeafletGeotiff.leafletGeotiff(
 //   "../../../../../assets/images/ETc_16_5001_wgs.tif",
 //   {
 //     band: 0,
    
 //     name: "test",
 //     renderer: new LeafletGeotiff.LeafletGeotiff.Plotty({
 //       // displayMin: 0,
 //       // displayMax: 30,
 //       // arrowSize: 20,
 //       // clampLow: false,
 //       // clampHigh: true,
 //       colorScale: "greys",      
 //     })
     
 //   }
 // ).addTo(map)
 
 
 
 
 
 // var url_to_geotiff_file = "../../../../../assets/images/Albedo_parcelle.tif";
 
 // fetch(url_to_geotiff_file)
 //   .then(response => response.arrayBuffer())
 //   .then(arrayBuffer => {
 //     parse_georaster(arrayBuffer).then(georaster => {
 //       console.log("georaster:", georaster);
 
 //       /*
 //           GeoRasterLayer is an extension of GridLayer,
 //           which means can use GridLayer options like opacity.
 
 //           Just make sure to include the georaster option!
 
 //           Optionally set the pixelValuesToColorFn function option to customize
 //           how values for a pixel are translated to a color.
 
 //           http://leafletjs.com/reference-1.2.0.html#gridlayer
 //       */
 //       var layer = new GeoRasterLayer({
 //           georaster: georaster,
 //           // opacity: 1,
 //           // pixelValuesToColorFn: values => values[0] === 42 ? '#ffffff' : '#000000',
 //           // resolution: 64 // optional parameter for adjusting display resolution
 //       });
 //       layer.addTo(map);
 
 //       map.fitBounds(layer.getBounds());
 
 //   });
 // });
 
 
 
 
 
 
 // const test2 = LeafletGeotiff.leafletGeotiff(
 //   "../../../../../assets/images/Albedo_parcelle.tif",
 //   {
 //     band: 0,
 //     name: "test2",
 //     renderer: new LeafletGeotiff.LeafletGeotiff.VectorArrows({
 //       arrowSize: 20,
 //       displayMin: 0,
 //       displayMax: 6,
 //     })
 //   }
 // ).addTo(map);
 
 
 
 // const test3 = LeafletGeotiff.leafletGeotiff(
 //   "../../../../../assets/images/Albedo_parcelle.tif",
 //   {
 //     name: "test3",
 //   }
 // ).addTo(map);
 
 
 
 
 // var wmsLayer = L.tileLayer.wms('http://10.10.100.66:8080/geoserver/agro/wms', { 
 //   layers: 'ETc_26mai_5001_wgs',
 //   format: 'image/png',
 //   transparent: true,
 //   styles:'ETc_palette',
 // }).addTo(map);
  
 
 
//  var wmsLayer = L.tileLayer.wms('http://localhost:8080/geoserver/fadwa/wms', { 
//    layers: 'raster5001',
//    format: 'image/png',
//    transparent: true,
//    // styles:'ETc_palette',
//  }).addTo(map);
  
   setTimeout(function ggg() {
 
     var googleStreets = L.tileLayer('http://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}&hl=ar-MA&gl=MA',{
       subdomains:['mt0','mt1','mt2','mt3']
     });
     var googleHybrid = L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}&hl=ar-MA&gl=MA',{
       subdomains:['mt0','mt1','mt2','mt3']
     });
 
     var googleSat = L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}&hl=ar-MA&gl=MA',{
       subdomains:['mt0','mt1','mt2','mt3']
     });
 
     var googleTerrain = L.tileLayer('http://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}&hl=ar-MA&gl=MA',{
       subdomains:['mt0','mt1','mt2','mt3']
     });
     var baseMaps = {
       "Open Street Map" : googleStreets,
       "Hybrid" : googleHybrid,
       "satellite" : googleSat,
       "Terrain" : googleTerrain
     };
 
 
     var overlayMaps = {};
     overlayMaps["Exploitation"]= exploitationsGroupe
    //  overlayMaps["Parcelles"]= parcelle
     overlayMaps["Capteurs"]= capteursGroupe
     capteursList.forEach(element1 => {
       var groupe = []
       capteursList.forEach(element2 => {
         if(element1.mesure == element2.mesure){
           groupe.push(element1.feature)
           groupe.push(element2.feature)
         }
       });
       if(element1.mesure == 'temperature'){
         overlayMaps['<img width="20px" height="20px" src="../../../../../assets/images/temperature.svg" /> Température']= L.layerGroup(groupe)
       }else if(element1.mesure == 'humidity'){
         overlayMaps['<img width="20px" height="20px" src="../../../../../assets/images/humidity.svg" /> Humidité']= L.layerGroup(groupe)
       }else if(element1.mesure == 'light'){
         overlayMaps['<img width="20px" height="20px" src="../../../../../assets/images/light.svg" /> Luminosité']= L.layerGroup(groupe)
       }else if(element1.mesure == 'soil_temperature'){
         overlayMaps['<img width="20px" height="20px" src="../../../../../assets/images/soil_temperature.svg" /> Température du sol']= L.layerGroup(groupe)
       }else if(element1.mesure == 'soil_humidity'){
         overlayMaps['<img width="20px" height="20px" src="../../../../../assets/images/soil_humidity.svg" /> Humidité du sol']= L.layerGroup(groupe)
       }else if(element1.mesure == 'soil_conductivity'){
         overlayMaps['<img width="20px" height="20px" src="../../../../../assets/images/soil_conductivity.svg" /> Conductivité du sol']= L.layerGroup(groupe)
       }else if(element1.mesure == 'ultrasonic_level'){
         overlayMaps['<img width="20px" height="20px" src="../../../../../assets/images/ultrasonic_level.svg" /> niveau ultrasonique']= L.layerGroup(groupe)
       }
 
 
     });
 
 
     L.control.layers(baseMaps,overlayMaps).addTo(map);
 
 
 
 
 
   }, 4000)
 
 
 map.attributionControl.addAttribution('agroconcept');
 
 }
 
 
 
}
